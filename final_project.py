import math
import pandas as pd
import yfinance as yf
from pmdarima import auto_arima
import matplotlib.pyplot as plt
import numpy as np
import statsmodels
from statsmodels.tsa.holtwinters import ExponentialSmoothing as ES
from sklearn.preprocessing import MinMaxScaler as MS
from keras.preprocessing.sequence import TimeseriesGenerator as TG
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.metrics import mean_squared_error as mse

path = r"C:\Users\jorda\OneDrive\Documents\MFinA\FINC 595 - SPC TP FInancial Time Series\NIKE Inc NYSE NKE Financials.xls"
df = yf.download(tickers=["NKE", "^GSPC"], start='2006-07-01', end='2022-03-31', parse_dates=True)['Close']

start_date = '2006-09-30'
end_date = '2022-03-31'
dates = (pd.date_range(pd.to_datetime(start_date),
                       pd.to_datetime(end_date) + pd.offsets.QuarterBegin(1), freq='Q').tolist())

income_statement = pd.read_excel(path, sheet_name="Income Statement", index_col=[0], header=[4])
income_statement.columns = dates
dep_drop = income_statement.T
dep_drop = dep_drop.drop(columns=['Depreciation & Amort.'])
income_statement = dep_drop.T

cash_flow = pd.read_excel(path, sheet_name="Cash Flow", index_col=[0], header=[4])
cash_flow.columns = dates
frame = pd.concat([income_statement, cash_flow])
frame = frame.T
frame['corporate_tax_rate'] = np.where(frame['Income Tax Expense'] > 1, frame['Income Tax Expense'] / frame['EBIT'], -1)

for index, row in frame.iterrows():
    if row['corporate_tax_rate'] > 0.50 or row['corporate_tax_rate'] < 0.05:
        frame.drop(index, inplace=True)

corporate_tax_rate = frame['corporate_tax_rate'].mean()

frame = frame.replace('-', 0)

frame['FCFF'] = frame['EBIT'] * (1-corporate_tax_rate) + frame['Depreciation & Amort.'] + frame['Capital Expenditure'] - frame['Change in Net Working Capital']

for index, row in frame.iterrows():
    if row['FCFF'] < 0:
        frame.drop(index, inplace=True)

training_set = pd.DataFrame(frame['FCFF'].iloc[:42])
testing_set = pd.DataFrame(frame['FCFF'].iloc[42:49])

EWMA_model = ES(np.asarray(training_set), trend=None).fit()
DES_model = ES(np.asarray(training_set), trend='mul').fit()
TES_model = ES(np.asarray(training_set), trend='mul', seasonal='mul', seasonal_periods=4).fit()


SARIMA_model = auto_arima(training_set['FCFF'], start_p=0, start_d=0, start_q=0,
                   max_p=4, max_d=4, max_q=4, seasonal=True, m=4, start_P=0, start_D=0, start_Q=0,
                  max_P=4, max_D=4, max_Q=4, trace=True)


scaler = MS()
scaler.fit(training_set)
train_set_scaled = scaler.transform(training_set)
test_set_scaled = scaler.transform(testing_set)

n_input = 4
n_features = 1

generator = TG(train_set_scaled, train_set_scaled, length=n_input, batch_size=1)

alpha = 5
hidden_nodes = math.ceil(len(training_set)/(alpha * (n_input + n_features))) * 100

NN_model = Sequential()
NN_model.add(LSTM(hidden_nodes, activation='relu', input_shape=(n_input, n_features)))
NN_model.add(Dense(1, activation='linear'))

NN_model.compile(loss='mse', optimizer='adam')

# train the LSTM neural network on time series generated by TimeseriesGenerator
NN_model.fit(generator, epochs=500)

test_predictions_scaled = []

first_eval_batch = train_set_scaled[-4:]

first_eval_batch = first_eval_batch.reshape((1, n_input, n_features))
current_batch = first_eval_batch

for i in range(len(testing_set)):
    # predict next one time period
    current_prediction = NN_model.predict(current_batch)[0]
    test_predictions_scaled.append(current_prediction)
    # update current_batch to include 11 elements of previous batch plus current_prediction
    current_batch = np.append(current_batch[:, 1:, :], [[current_prediction]], axis=1)

training_set['EWMA'] = EWMA_model.fittedvalues
training_set['DES'] = DES_model.fittedvalues
training_set['TES'] = TES_model.fittedvalues

EWMA_forecast = EWMA_model.forecast(7)
# DES_forecast = 10**DES_forecast
testing_set['EWMA_predictions'] = EWMA_forecast
DES_forecast = DES_model.forecast(7)
# DES_forecast = 10**DES_forecast
testing_set['DES_predictions'] = DES_forecast
TES_forecast = TES_model.forecast(7)
# TES_forecast = 10**TES_forecast
testing_set['TES_predictions'] = TES_forecast

SARIMA_predictions = SARIMA_model.predict(n_periods=7)
# SARIMA_predictions = 10**SARIMA_predictions
testing_set['SARIMA_predictions'] = SARIMA_predictions

# get the original time series back (inverse the MinMax Scaling)
predictions = scaler.inverse_transform(test_predictions_scaled)
# training_set = 10**training_set
# predictions = 10**predictions
testing_set['NN_predictions'] = predictions

fig, ax = plt.subplots(nrows=2, ncols=3)
ax1 = ax[0, 0]
ax2 = ax[0, 1]
ax3 = ax[0, 2]
ax4 = ax[1, 0]
ax5 = ax[1, 1]
ax6 = ax[1, 2]
# plot train set, test set, predictions
ax1.plot(testing_set['FCFF'], c='red')
ax2.plot(testing_set[['FCFF', 'NN_predictions']])
ax3.plot(testing_set[['FCFF', 'SARIMA_predictions']])
ax4.plot(testing_set[['FCFF', 'EWMA_predictions']])
ax5.plot(testing_set[['FCFF', 'DES_predictions']])
ax6.plot(testing_set[['FCFF', 'TES_predictions']])


fig.legend()
fig.show()

# training_set["FCFF"].plot(c='red')
testing_set['FCFF'].plot(legend=True, c='red')
testing_set['NN_predictions'].plot(legend=True, c='blue')
plt.show()

testing_set['FCFF'].plot(legend=True, c='red')
testing_set['SARIMA_predictions'].plot(legend=True, c='green')
plt.show()

testing_set['FCFF'].plot(legend=True, c='red')
testing_set['EWMA_predictions'].plot(legend=True, c='brown')
plt.show()

testing_set['FCFF'].plot(legend=True, c='red')
testing_set['DES_predictions'].plot(legend=True, c='purple')
plt.show()

testing_set['FCFF'].plot(legend=True, c='red')
testing_set['TES_predictions'].plot(legend=True, c='black')

plt.show()


EWMA_mse = np.sqrt(mse(testing_set['FCFF'], testing_set['EWMA_predictions']))
DES_mse = np.sqrt(mse(testing_set['FCFF'], testing_set['DES_predictions']))
TES_mse = np.sqrt(mse(testing_set['FCFF'], testing_set['TES_predictions']))
SARIMA_mse = np.sqrt(mse(testing_set['FCFF'], testing_set['SARIMA_predictions']))
NN_mse = np.sqrt(mse(testing_set['FCFF'], testing_set['NN_predictions']))

print(NN_mse)
print(EWMA_mse)
print(DES_mse)
print(TES_mse)
print(SARIMA_mse)

free_cash_flows = np.log10(pd.DataFrame(frame['FCFF'].iloc[:]))
set = pd.DataFrame(frame['FCFF'].iloc[:])

start_date = '2022-06-30'
end_date = '2025-03-31'
forecast_dates = (pd.date_range(pd.to_datetime(start_date),
                                pd.to_datetime(end_date) + pd.offsets.QuarterBegin(1), freq='Q').tolist())

final_TES_model = ES(np.asarray(set), trend='mul', seasonal='add', seasonal_periods=4).fit()
final_TES_predictions = final_TES_model.forecast(12)
# final_TES_predictions = 10**final_TES_predictions

final_SARIMA_model = auto_arima(free_cash_flows, start_p=0, start_d=0, start_q=0,
                   max_p=4, max_d=4, max_q=4, seasonal=True, m=4, start_P=0, start_D=0, start_Q=0,
                  max_P=4, max_D=4, max_Q=4, trace=True)

final_SARIMA_forecast = final_SARIMA_model.predict(n_periods=12)

final_SARIMA_forecast = 10**final_SARIMA_forecast

frame['FCFF'].plot(legend=True, c='black')
plt.plot(forecast_dates, final_SARIMA_forecast, c='green')
# plt.plot(forecast_dates, final_TES_predictions, c='red')

plt.legend()
plt.show()

# Calculate the WACC
# Import BS
balance_sheet = pd.read_excel(path, sheet_name="Balance Sheet", index_col=[0], header=[3])
balance_sheet.columns = dates

balance_sheet = balance_sheet.T

# calculate beta
df_returns = df.pct_change()
cov = df_returns.cov()
var = df_returns['^GSPC'].var()

Beta = cov.loc['NKE', '^GSPC'] / var
# calculate Re and Rd
cost_of_equity = 0.0147 + ((0.3092 - 0.0147) * Beta)
cost_of_debt = 0.0275

WACC = ((23768/38577)  # balance_sheet['Total Liabilities'].iloc[-1]/balance_sheet['Total Liabilities And Equity'].iloc[-1]
        * cost_of_debt * (1 - corporate_tax_rate)) \
       + ((14809/38577) * cost_of_equity)  # balance_sheet['Total Equity'].iloc[-1]/balance_sheet['Total Liabilities And Equity'].iloc[-1]
print(WACC)

# Estimate growth rate g
# Import IS
income_statement = income_statement.T

# Extract last 8 quarters
g_frame = income_statement['Basic EPS Excl. Extra Items'].iloc[-9:]
g_frame = g_frame.pct_change()
g_frame.dropna(inplace=True)

g_values = g_frame.values.tolist()

# calculate geometric mean
total = 1
for val in g_values:
    total *= (1 + val)
g = total**(1/len(g_values)) - 1
print(g)

# calculate predicted FCFF for next 3 years
year_1 = final_SARIMA_forecast[:4].sum()
year_2 = final_SARIMA_forecast[4:8].sum()
year_3 = final_SARIMA_forecast[8:].sum()

# Find the present value of the company
FV = ((year_1/(1 + WACC)) + (year_2/((WACC-g) * ((1 + WACC) ** 2))) + (year_3/((WACC-g) * ((1 + WACC) ** 3))))
print(FV)

# Calculate the Intrinsic stock value
stock_value = (FV - 23768) / 1576
print(stock_value)

tesyear_1 = final_TES_predictions[:4].sum()
tesyear_2 = final_TES_predictions[4:8].sum()
tesyear_3 = final_TES_predictions[8:].sum()

# Find the present value of the company
tesFV = ((tesyear_1/(1 + WACC)) + (tesyear_2/((WACC-g) * ((1 + WACC) ** 2))) + (tesyear_3/((WACC-g) * ((1 + WACC) ** 3))))
print(tesFV)

# Calculate the Intrinsic stock value
tesstock_value = (tesFV - 23768) / 1576
print(tesstock_value)
